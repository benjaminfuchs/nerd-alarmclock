#!/usr/bin/python3
# --------------------------------------------------------------------------
# Class definition of SensorsControllerThread - utility functions for the sensors
#
# Author: Benjamin Fuchs
# License: GPL3
#
# Website: https://github.com/benjaminfuchs/who_disposer
#
# --------------------------------------------------------------------------

import time
from threading import Thread

from nclock.Button import Button
from nclock.Sensor import Sensor


class SensorsControllerThread(Thread):
    """ SensorsControllerThread thread """

    INIT_MEASURES = 10
    INIT_TIME = 2
    POLL_INTERVAL = 0.2

    def __init__(self, settings):
        """ Constructor """

        super(SensorsControllerThread, self).__init__(
            name="SensorsControllerThread")
        self._settings = settings
        self._settings.log.msg("SensorsControllerThread: init")
        self._stop_event = settings.stop_event
        self._settings.log.msg(
            "SensorsControllerThread: setting up %s" % settings.get_value('GPIO', 'button'))
        self._button = Button(int(settings.get_value('GPIO', 'button')))
        self._sensor = Sensor(0x70)
        self._state = settings.get('state')
        self._sensor_threshold = settings.get('sensor.threshold')
        self._expected_distance = None
        self._button_count = 0
        self._button.add_listener(self._update_button)
        self._button.add_listener(self._update_sensor)

    def run(self):
        """ run method of thread """

        self._settings.log.msg(
            "SensorsControllerThread: running ...")
        if self._state == "starting":
            values = []
            for _ in range(SensorsControllerThread.INIT_MEASURES):
                values.append(self._sensor.distance())
                time.sleep(SensorsControllerThread.INIT_TIME /
                           SensorsControllerThread.INIT_MEASURES)
            self._expected_distance = sum(values) / len(values)
            self._settings.log.msg(
                "SensorsControllerThread: expected distance is %s (%s)" % (self._expected_distance, str(values)))
            self._settings.log.msg(
                "SensorsControllerThread: changing state to running")
            self._settings.set("state", "running")

        while not self._stop_event.wait(SensorsControllerThread.POLL_INTERVAL):
            self._update_sensor()

        self._settings.log.msg("SensorsControllerThread: shutdown")


    def _update_button(self, new):
        """ check button status """

        name = "button.status"
        self._settings.log.msg("SensorsControllerThread: button (%s)" % new)

        if new:
            value = "on"
        else:
            value = "off"
        self._settings.set(name, value)


    def _update_sensor(self, new):
        """ check sensor status """

        name = "sensor.status"
        old_value = self._settings.get(name)

        if new < (self._expected_distance * self._sensor_threshold) or \
           new > (self._expected_distance * self._sensor_threshold):
            value = "on"
            self._settings.log.msg("SensorsControllerThread: Hand detected (%s)" % new)
        else:
            value = "off"
        if old_value != value:
            self._settings.set(name, value)
