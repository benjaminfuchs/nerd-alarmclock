#!/usr/bin/python3
# --------------------------------------------------------------------------
# Class definition of SensorsControllerThread - utility functions for the sensors
#
# Author: Benjamin Fuchs
# License: GPL3
#
# Website: https://github.com/benjaminfuchs/who_disposer
#
# --------------------------------------------------------------------------

import time
from threading import Thread

from nclock.Button import Button
from nclock.SRF02 import SRF02
from nclock.HCSR04 import HCSR04


class SensorsControllerThread(Thread):
    """ SensorsControllerThread thread """

    INIT_MEASURES = 10
    INIT_TIME = 2
    POLL_INTERVAL = 0.05

    def __init__(self, settings):
        """ Constructor """

        super(SensorsControllerThread, self).__init__(
            name="SensorsControllerThread")
        self._settings = settings
        self._settings.log.msg("SensorsControllerThread: init")
        self._stop_event = settings.stop_event
        self._settings.log.msg(
            "SensorsControllerThread: setting up %s" % settings.get_value('GPIO', 'button'))
        self._button = Button(int(settings.get_value('GPIO', 'button')))
        self._sensor_type = settings.get_value('SENSOR', 'ultraschall')
        if self._sensor_type == "SRF02":
            self._sensor = SRF02(0x70)
        elif self._sensor_type == "HCSR04":
            self._sensor = HCSR04(27, 18)
        else:
            self._settings.log.msg(
                "SensorsControllerThread: [ERROR] Unkown sensor type (%s)" % str(self._sensor_type))
        self._state = settings.get('state')
        self._sensor_threshold = settings.get('sensor.threshold')
        self._button_status = None
        self._button_count = 0
        self._button.add_listener(self._update_button)
        self.start()

    def run(self):
        """ run method of thread """

        self._settings.log.msg(
            "SensorsControllerThread: running ...")
        if self._state == "starting":
            values = []
            for _ in range(SensorsControllerThread.INIT_MEASURES):
                self._sensor.distance()

            self._settings.log.msg(
                "SensorsControllerThread: changing state to running")
            self._settings.set("state", "running")

        while not self._stop_event.wait(SensorsControllerThread.POLL_INTERVAL):
            self._update_sensor()
            if self._button_status == "on":
                self._button_count += 1
                if self._button_count > 3 / SensorsControllerThread.POLL_INTERVAL:
                    self._settings.set(name, "long")
                    self._button_count = 0
                    self._settings.log.msg("SensorsControllerThread: button (%s)" % "long")

        self._sensor.kill()
        self._sensor.join()
        self._settings.log.msg("SensorsControllerThread: shutdown")

    def _update_button(self, new):
        """ check button status """

        name = "button.status"

        if new:
            value = "on"
            self._settings.log.msg("SensorsControllerThread: button (%s)" % new)
        else:
            value = "off"
        self._button_status = value
        self._settings.set(name, value)

    def _update_sensor(self):
        """ check button status """

        name = "sensor.status"
        old_value = self._settings.get(name)
        distance = self._sensor.distance()
        self._settings.log.msg(
            "SensorsControllerThread: distancen is %s" % distance)

        if distance < self._sensor_threshold:
            value = "on"
        else:
            value = "off"
        if old_value != value:
            self._settings.set(name, value)
